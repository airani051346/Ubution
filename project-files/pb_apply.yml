# pb_apply.yml
- name: Apply rendered config to device via SSH (raw) and archive file
  hosts: "{{ inventory_hostname }}"
  gather_facts: false

  vars:
    # Controller-side paths
    work_dir: "{{ playbook_dir }}"
    render_dir: "{{ work_dir }}/rendered-config"
    done_dir: "{{ work_dir }}/config-done"
    cfg_path: "{{ render_dir }}/{{ inventory_hostname }}.cfg"
    done_path: "{{ done_dir }}/{{ inventory_hostname }}.cfg"

    # Toggle: set false to preview only (no device changes)
    apply_changes: true

  tasks:
    - name: Ensure output directories exist (controller)
      file:
        path: "{{ item }}"
        state: directory
        mode: "0755"
      loop:
        - "{{ render_dir }}"
        - "{{ done_dir }}"
      delegate_to: localhost

    - name: Verify rendered config exists (controller)
      stat:
        path: "{{ cfg_path }}"
      register: cfg_stat
      delegate_to: localhost

    - name: Stop if rendered config is missing
      fail:
        msg: "Config file not found: {{ cfg_path }}. Run pb_render.yml first."
      when: not cfg_stat.stat.exists
      delegate_to: localhost

    - name: Read config file (controller)
      set_fact:
        cfg_text: >-
          {{ lookup('file', cfg_path) | regex_replace('^\ufeff','') | replace('\r\n','\n') | replace('\r','\n') }}
      delegate_to: localhost

    - name: Split, trim, drop blanks/comments
      set_fact:
        lines_all: >-
          {{
            cfg_text.splitlines()
            | map('trim')
            | reject('match','^$')
            | reject('match','^#')
            | list
          }}
      delegate_to: localhost

    - name: Parse into execution blocks (supports ::Sleep and ::ExpertMode/End)
      set_fact:
        exec_plan: |-
          {%- set blocks = [] -%}
          {%- set current = {'type':'clish','items': []} -%}
          {%- for ln in lines_all -%}
            {%- if ln is match('^::Sleep\\s+\\d+$') -%}
              {%- if current['items'] | length > 0 -%}{%- set _ = blocks.append(current) -%}{%- endif -%}
              {%- set current = {'type':'clish','items': []} -%}
              {%- set _ = blocks.append({'type':'sleep','seconds': (ln.split()[1] | int)}) -%}

            {%- elif ln is match("^::ExpertMode\\b") -%}
              {%- if current['items'] | length > 0 -%}{%- set _ = blocks.append(current) -%}{%- endif -%}
              {# attributes on ::ExpertMode #}
              {%- set cmd_enter   = (ln | regex_findall("command=([^\\s]+)")) | default(['expert']) | first -%}
              {%- set prompt_pre  = (ln | regex_findall("prompt='([^']*)'")) | default(['']) | first -%}
              {%- set prompt_ex   = (ln | regex_findall("expert-prompt='([^']*)'")) | default(['#']) | first -%}
              {# password is the token between prompt=... and expert-prompt=... #}
              {%- set pw_match_q  = (ln | regex_findall("prompt='[^']*'\\s+'([^']+)'\\s+expert-prompt")) | default([]) -%}
              {%- set pw_match_b  = (ln | regex_findall("prompt='[^']*'\\s+([^\\s]+)\\s+expert-prompt")) | default([]) -%}
              {%- set pw_value    = (pw_match_q or pw_match_b or ['']) | first -%}
              {%- set current = {'type':'expert_mode','cmd_enter':cmd_enter,'prompt_pre':prompt_pre,'prompt_expert':prompt_ex,'password':pw_value,'items': []} -%}

            {%- elif ln is match("^::ExpertModeEnd\\b") -%}
              {%- set cmd_exit    = (ln | regex_findall("command=([^\\s]+)")) | default(['exit']) | first -%}
              {%- set prompt_exit = (ln | regex_findall("prompt='([^']*)'")) | default(['>']) | first -%}
              {%- if current['type'] == 'expert_mode' -%}
                {%- set current = current | combine({'cmd_exit':cmd_exit,'prompt_exit':prompt_exit}) -%}
                {%- set _ = blocks.append(current) -%}
              {%- endif -%}
              {%- set current = {'type':'clish','items': []} -%}

            {%- elif ln is match("^::") -%}
              {# ignore any other :: markers #}

            {%- else -%}
              {%- set _ = current['items'].append(ln) -%}
            {%- endif -%}
          {%- endfor -%}
          {%- if current['items'] | length > 0 -%}{%- set _ = blocks.append(current) -%}{%- endif -%}
          {{ blocks | to_json }}
      delegate_to: localhost

    - name: Convert plan JSON to list
      set_fact:
        exec_blocks: "{{ exec_plan | from_json }}"
      delegate_to: localhost

    - name: Preview plan (counts)
      debug:
        msg:
          clish_lines: "{{ exec_blocks | selectattr('type','equalto','clish') | map(attribute='items') | sum(start=[]) | length }}"
          sleep_blocks: "{{ exec_blocks | selectattr('type','equalto','sleep') | list | length }}"
          expert_blocks: "{{ exec_blocks | selectattr('type','equalto','expert_mode') | list | length }}"

    - block:
        - name: Sleep blocks (remote)
          raw: "sleep {{ item.seconds }}"
          loop: "{{ exec_blocks | selectattr('type','equalto','sleep') | list }}"
          when: apply_changes | bool
          changed_when: true

        - name: Run clish lines (Gaia Full gateways)
          raw: "clish -s -c {{ line | quote }}"
          loop: "{{ exec_blocks | selectattr('type','equalto','clish') | map(attribute='items') | sum(start=[]) }}"
          loop_control:
            loop_var: line
          when:
            - apply_changes | bool
            - gaia_mode | default('spark') == "full"

        - name: Run clish lines (Spark gateways, default)
          raw: "{{ line }}"
          loop: "{{ exec_blocks | selectattr('type','equalto','clish') | map(attribute='items') | sum(start=[]) }}"
          loop_control:
            loop_var: line
          when:
            - apply_changes | bool
            - gaia_mode | default('spark') != "full"

        - name: Run ExpertMode blocks (remote) using expect
          vars:
            pre_prompt:   "{{ item.prompt_pre    | default('password:') }}"
            ex_prompt:    "{{ item.prompt_expert | default('#') }}"
            exit_cmd:     "{{ item.cmd_exit      | default('exit') }}"
            # List of commands to send after expert prompt appears
            expert_cmds:  "{{ (item.items | list) + [exit_cmd] }}"
          expect:
            command: "bash -lc {{ item.cmd_enter | quote }}"
            responses:
              "{{ pre_prompt }}": "{{ item.password }}"
              "{{ ex_prompt }}": "{{ expert_cmds }}"
            timeout: 300
          loop: "{{ exec_blocks | selectattr('type','equalto','expert_mode') | list }}"
          when: apply_changes | bool
          changed_when: true
          register: expert_mode_rs

          # If your managed host lacks Python/pexpect, use this instead (runs from controller):
          # delegate_to: localhost
          # vars:
          #   ssh_user: "{{ ansible_user | default('admin') }}"
          # expect:
          #   command: >-
          #     ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -tt {{ ssh_user }}@{{ inventory_hostname }} {{ item.cmd_enter }}
          #   responses:
          #     "{{ pre_prompt }}": "{{ item.password }}"
          #     "{{ ex_prompt }}": "{{ expert_cmds }}"
          #   timeout: 300

        - name: Mark apply success
          set_fact:
            apply_ok: true

      rescue:
        - name: Mark apply failed
          set_fact:
            apply_ok: false
        - debug:
            msg: "Apply failed â€” leaving rendered file in {{ render_dir }}/"

      always:
        - name: Move file to config-done/ if apply succeeded (controller)
          command: >
            bash -lc "mv -f {{ cfg_path | quote }} {{ done_path | quote }}"
          when: apply_ok | default(false) | bool
          delegate_to: localhost
